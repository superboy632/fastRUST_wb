Что выведет программа? Объяснить вывод программы. Объяснить как работают Drop и порядок их вызовов.

```
struct Example(i32);

impl Drop for Example {

    fn drop(&mut self) {

        println!("{}", self.0);

    }

}

struct ExampleWrap(Example);

impl Drop for ExampleWrap {

    fn drop(&mut self) {
        let e = std::mem::replace(&mut self.0, Example(0));
        println!("wrap {}", e.0);
    }

}

fn main() {

    Example(1);

    let _e2 = Example(2);

    let _e3 = Example(3);

    let _ = Example(4);

    let mut _e5;

    _e5 = Some(Example(5));

    _e5 = None;

    let e6 = Example(6);

    drop(e6);

    let e7 = Example(7);

    std::mem::forget(e7);

    ExampleWrap(Example(8));

}
```

В данной задаче задаются две структуры Example(i32), состоящей из одного поля типа i32, и стрктуру ExampleWrap(Example), аналогичную первой, но состоящей из поля ипа структуры Example<br>
Далее реализуются для каждых структур типажи Drop реализующие методы drop<br>
Первый трейт для Example(i32) реализует метод drop, который печает элемент первого поля<br>
Второй трейт для ExampleWrap реализует метод drop, который перемещает в поле example значение 0 и вовращает в переменную e замененное значение. Это значение выводится<br>

Типаж Drop отвечает за то, что когда значение выходит за область видимости, значение удаляется из пямяти

Далее разберем функцию main:
    
-  Example(1); - создаем экземпляр структуры, она сразу выходит за облатсь видимости
-  let _e2 = Example(2); - далее приравниваем к _e2 структуру Example(2)
-  let _e3 = Example(3); - далее приравниваем к _e2 структуру Example(2)
-  let _ = Example(4); - создание временной переменной равной ээкземпляру структуры. Сразу выходит за область видимости
-  let mut _e5;
   _e5 = Some(Example(5)); - так же задаем значение переменной
  _e5 = None; - при приравнивании к none вызывается drop
- let e6 = Example(6);

  drop(e6); - создаем экземпляр структуры и вызываем drop
- let e7 = Example(7);

  std::mem::forget(e7); - создаем экземпляр и применяем forget, который "забывает" об этой переменной в пямяти
- ExampleWrap(Example(8)); - создаем структуру, которая в момент drop выведет 8 и вернет  Example(0)
- как только функция main закончилась будут вызваны методы drop, но в обратном порядке. 
- Вывод значений будет выглядеть следующим образом: 
1) 1
2) 4
3) 5
4) 6
5) wrap 8
6) 8
7) 0
8) 3
9) 2