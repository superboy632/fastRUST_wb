// в данном задании используем generic types, а именно PartialEq - для возможности сравнения и Clone для клонирования
// &[T] - заимствование среза массива типа T. Позволяет работать с частью массива любого типа. & говорит нам о том, что мы работаем с заимствованием, а не владением
fn set_intersection<T:PartialEq + Clone>(set_1: &[T], set_2: &[T]) -> Vec<T> {
    let mut set_3 = Vec::new();
    for i in set_1 {
        if set_2.contains(i) && !set_3.contains(i) { // проверяем, что множество 2 содержит элемент из множества 1 и при этом он уникален и не был до этого добавлен
            set_3.push(i.clone()); // в данной строке i.clone нужно для того, чтобы избежать ошибки с заимствованием. Мы просто создаем новый экземпляр копирую данные по адресу i
        }
    }
    set_3
}

fn main() {
    let set_1 = vec![1, 2, 3, 4, 5];
    let set_2 = vec![4, 5, 6, 7, 8];
    let set_3 = set_intersection(&set_1, &set_2);
    println!("{:?}", set_3);
}
